(* 'ABORT' *)
abort = 'ABORT' [ 'TRANSACTION' | 'WORK' ] ;

(* 'ALTER' 'DATABASE' *)
alter_database =
  'ALTER' 'DATABASE' name ( [ [ 'WITH' ]  alter_database_option { alter_database_option } ]
                        | 'RENAME' 'TO' name
                        | 'OWNER' 'TO' ( new_owner | 'CURRENT_USER' | 'SESSION_USER' )
                        | 'SET' run_time_parameter ( 'TO' | '=' ) ( value | 'DEFAULT' )
                        | 'SET' run_time_parameter 'FROM' 'CURRENT'
                        | 'RESET' run_time_parameter
                        | 'RESET' 'ALL' ) ;

alter_database_option =
  ( 'ALLOW_CONNECTIONS' allowconn | 'CONNECTION' 'LIMIT' connlimit | 'IS_TEMPLATE' istemplate ) ;

(* 'ALTER' 'DEFAULT' 'PRIVILEGES' *)
alter_default_priv = 'ALTER' 'DEFAULT' 'PRIVILEGES'
                               [ 'FOR' ( 'ROLE' | 'USER' ) role_name { ',' role_name } ]
                               [ 'IN' 'SCHEMA' schema_name { ',' schema_name } ]
                               abbr_grant_or_revoke ;

abbr_grant_or_revoke = a_grant_table
                            | a_grant_seq
                            | a_grant_func
                            | a_grant_type
                            | a_grant_schema
                            | a_revoke_table
                            | a_revoke_seq
                            | a_revoke_func
                            | a_revoke_type
                            | a_revoke_schema ;

a_grant_table = 'GRANT' ( grant_table_priv { ',' grant_table_priv }
                                   | 'ALL' [ 'PRIVILEGES' ] )
                          'ON' 'TABLES'
                          'TO' grant_role_spec { ',' grant_role_spec } [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_table_priv = 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'TRUNCATE' | 'REFERENCES' | 'TRIGGER' ;

a_grant_seq = 'GRANT' ( grant_seq_priv { ',' grant_seq_priv }
                                  | 'ALL' [ 'PRIVILEGES' ] )
                        'ON' 'SEQUENCES'
                        'TO' grant_role_spec { ',' grant_role_spec } [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_seq_priv = 'USAGE' | 'SELECT' | 'UPDATE' ;

a_grant_func = 'GRANT' ( 'EXECUTE' | 'ALL' [ 'PRIVILEGES' ] )
                          'ON' ( 'FUNCTIONS' | 'ROUTINES' )
                          'TO' grant_role_spec { ',' grant_role_spec } [ 'WITH' 'GRANT' 'OPTION' ] ;

a_grant_type = 'GRANT' ( 'USAGE' | 'ALL' [ 'PRIVILEGES' ] )
                          'ON' 'TYPES'
                          'TO' grant_role_spec { ',' grant_role_spec } [ 'WITH' 'GRANT' 'OPTION' ] ;

a_grant_schema = 'GRANT' ( 'USAGE' | 'CREATE' | 'ALL' [ 'PRIVILEGES' ] )
                            'ON' 'SCHEMAS'
                            'TO' grant_role_spec { ',' grant_role_spec } [ 'WITH' 'GRANT' 'OPTION' ] ;

a_revoke_table = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                              ( grant_table_priv { ',' grant_table_priv }
                                | 'ALL' [ 'PRIVILEGES' ] )
                            'ON' 'TABLES'
                            'FROM' grant_role_spec { ',' grant_role_spec }
                            [ 'CASCADE' | 'RESTRICT' ] ;

a_revoke_seq = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                            ( grant_seq_priv { ',' grant_seq_priv }
                              | 'ALL' [ 'PRIVILEGES' ] )
                          'ON' 'SEQUENCES'
                          'FROM' grant_role_spec { ',' grant_role_spec }
                          [ 'CASCADE' | 'RESTRICT' ] ;

a_revoke_func = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                          ( 'EXECUTE' | 'ALL' [ 'PRIVILEGES' ] )
                          'ON' ( 'FUNCTIONS' | 'ROUTINES' )
                          'FROM' grant_role_spec { ',' grant_role_spec }
                          [ 'CASCADE' | 'RESTRICT' ] ;

a_revoke_type = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                          ( 'USAGE' | 'ALL' [ 'PRIVILEGES' ] )
                          'ON' 'TYPES'
                          'FROM' grant_role_spec { ',' grant_role_spec }
                          [ 'CASCADE' | 'RESTRICT' ] ;

a_revoke_schema = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                            ( 'USAGE' | 'CREATE' | 'ALL' [ 'PRIVILEGES' ] )
                            'ON' 'SCHEMAS'
                            'FROM' grant_role_spec { ',' grant_role_spec }
                            [ 'CASCADE' | 'RESTRICT' ] ;

(* 'ALTER' 'DOMAIN' *)
alter_domain_default = 'ALTER' 'DOMAIN' name
    ( 'SET' 'DEFAULT' expression | 'DROP' 'DEFAULT' ) ;

alter_domain_rename = 'ALTER' 'DOMAIN' name
    'RENAME' 'TO' name ;

(* 'ALTER' 'FUNCTION' *)
alter_function = 'ALTER' 'FUNCTION' subprogram_name '(' [ subprogram_signature ] ')' \
                 ( special_fn_and_proc_attribute |
                   ( ( alterable_fn_and_proc_attribute | alterable_fn_only_attribute ) { ( alterable_fn_and_proc_attribute | alterable_fn_only_attribute ) } ['RESTRICT'] ) ) ;

special_fn_and_proc_attribute = (
    'RENAME' 'TO' subprogram_name
    | ( 'OWNER' 'TO' ( role_name | 'CURRENT_ROLE' | 'CURRENT_USER' | 'SESSION_USER' ) )
    | 'SET' 'SCHEMA' schema_name
    | ['NO'] 'DEPENDS' 'ON' 'EXTENSION' extension_name ) ;

(* 'ALTER' 'FOREIGN' 'DATA' 'WRAPPER' *)
alter_foreign_data_wrapper = 'ALTER' 'FOREIGN' 'DATA' 'WRAPPER' fdw_name 
                             [ 'HANDLER' handler_name | 'NO' 'HANDLER' ]
                             [ 'VALIDATOR' validator_name | 'NO' 'VALIDATOR' ]
                             [ 'OPTIONS' '(' alter_fdw_options ')']
                             [ 'OWNER' 'TO' new_owner ]
                             [ 'RENAME' 'TO' new_name ] ;

(* 'ALTER' 'FOREIGN' 'TABLE' *)
alter_foreign_table = 'ALTER' 'FOREIGN' 'TABLE' [ 'IF' 'EXISTS' ] table_name
                      alter_foreign_table_action { ',' alter_foreign_table_action } ;

alter_foreign_table_action =
  ( 'ADD' [ 'COLUMN' ] column_name data_type [ 'COLLATE' collation] [ alter_column_constraint { alter_column_constraint } ]
    | 'RENAME' 'TO' table_name
    | 'DROP' [ 'COLUMN' ] column_name [ 'RESTRICT' | 'CASCADE' ]
    | 'OWNER' 'TO' new_owner
    | 'OPTIONS' '(' alter_fdw_options ')' ) ;


(* 'ALTER' 'GROUP' *)
alter_group = 'ALTER' 'GROUP' role_specification ( 'ADD' | 'DROP' ) 'USER' role_name { ',' role_name } ;

alter_group_rename = 'ALTER' 'GROUP' role_name 'RENAME' 'TO' new_role_name ;

(* 'ALTER' 'POLICY' *)
alter_policy = 'ALTER' 'POLICY' name 'ON' table_name
               [ 'TO' ( role_name | 'PUBLIC' | 'CURRENT_USER' | 'SESSION_USER' )
                 { ',' ( role_name | 'PUBLIC' | 'CURRENT_USER' | 'SESSION_USER' ) } ]
               [ 'USING' '(' using_expression ')' ]
               [ 'WITH' 'CHECK' '(' check_expression ')' ] ;

alter_policy_rename = 'ALTER' 'POLICY' name 'ON' table_name 'RENAME' 'TO' new_name ;

(* 'ALTER' 'PROCEDURE' *)
alter_procedure = 'ALTER' 'PROCEDURE' subprogram_name '(' [ subprogram_signature ] ')' \
                 ( special_fn_and_proc_attribute |
                   ( alterable_fn_and_proc_attribute { alterable_fn_and_proc_attribute } ['RESTRICT'] ) ) ;

(* 'ALTER' 'ROLE' *)
alter_role = 'ALTER' 'ROLE' role_specification [ [ 'WITH' ] alter_role_option { ',' alter_role_option } ] ;

alter_role_option = 'SUPERUSER'
              | 'NOSUPERUSER'
              | 'CREATEDB'
              | 'NOCREATEDB'
              | 'CREATEROLE'
              | 'NOCREATEROLE'
              | 'INHERIT'
              | 'NOINHERIT'
              | 'LOGIN'
              | 'NOLOGIN'
              | 'CONNECTION' 'LIMIT' connlimit
              | [ 'ENCRYPTED' ] 'PASSWORD' ''' password '''
              | 'PASSWORD' 'NULL'
              | 'VALID' 'UNTIL' ''' timestamp ''' ;

role_specification = role_name
                     | 'CURRENT_USER'
                     | 'SESSION_USER' ;

alter_role_rename = 'ALTER' 'ROLE' role_name 'RENAME' 'TO' new_role_name ;

new_role_name = name ;

alter_role_config = 'ALTER' 'ROLE' ( role_specification | 'ALL' ) [ 'IN' 'DATABASE' database_name ] config_setting ;

config_setting = 'SET' config_param ( 'TO' | '=' ) ( config_value | 'DEFAULT' )
                 | 'SET' config_param 'FROM' 'CURRENT'
                 | 'RESET' config_param
                 | 'RESET' 'ALL' ;

config_param = '<Text Literal>' ;
config_value = '<Text Literal>' ;

(* 'ALTER' 'SEQUENCE' *)
alter_sequence = 'ALTER' 'SEQUENCE' [ 'IF' 'EXISTS' ] sequence_name alter_sequence_options ;

alter_sequence_options = [ 'AS' seq_data_type ]
                           [ 'INCREMENT' [ 'BY' ] int_literal ]
                           [ 'MINVALUE' int_literal | 'NO' 'MINVALUE' ]
                           [ 'MAXVALUE' maxvalue | 'NO' 'MAXVALUE' ]
                           [ 'START' [ 'WITH' ] int_literal ]
                           [ 'RESTART' [ [ 'WITH' ] int_literal ] ]
                           [ 'CACHE' cache ]
                           [ 'OWNED BY' table_name.table_column | 'NONE' ] ;

seq_data_type = ( 'smallint' | 'integer' | 'bigint' ) ;

(* 'ALTER' 'SERVER' *) 
alter_server = 'ALTER' 'SERVER' server_name 
               [ 'VERSION' server_version ]
               [ 'OPTIONS' '(' alter_fdw_options ')' ]
               [ 'OWNER' 'TO' new_owner ] ;

(* 'ALTER' 'TABLE' *)
alter_table = 'ALTER' 'TABLE' table_expr
                        alter_table_action { ',' alter_table_action } ;

alter_table_action =
  ( 'ADD' [ 'COLUMN' ] column_name data_type [ alter_column_constraint { alter_column_constraint } ]
    | 'RENAME' 'TO' table_name
    | 'DROP' [ 'COLUMN' ] column_name [ 'RESTRICT' | 'CASCADE' ]
    | 'ADD' alter_table_constraint
    | 'DROP' 'CONSTRAINT' constraint_name [ 'RESTRICT' | 'CASCADE' ]
    | 'RENAME' [ 'COLUMN' ] column_name 'TO' column_name
    | 'DISABLE' 'ROW' 'LEVEL' 'SECURITY'
    | 'ENABLE' 'ROW' 'LEVEL' 'SECURITY'
    | 'FORCE' 'ROW' 'LEVEL' 'SECURITY'
    | 'NO' 'FORCE' 'ROW' 'LEVEL' 'SECURITY' ) ;

alter_table_constraint = [ 'CONSTRAINT' constraint_name ] (
                       'CHECK' '(' expression ')' |
                       'UNIQUE' '(' column_names ')' index_parameters |
                       'FOREIGN' 'KEY' '(' column_names ')' references_clause )
                       [ 'DEFERRABLE' | 'NOT' 'DEFERRABLE' ] [ 'INITIALLY' 'DEFERRED' | 'INITIALLY' 'IMMEDIATE' ] ;

alter_column_constraint = [ 'CONSTRAINT' constraint_name ]
                      (  'NOT' 'NULL'
                         | 'NULL'
                         | 'CHECK' '(' expression ')'
                         | 'DEFAULT' expression
                         | 'UNIQUE' index_parameters
                         | references_clause )
                      [ 'DEFERRABLE' | 'NOT' 'DEFERRABLE' ] [ 'INITIALLY' 'DEFERRED' | 'INITIALLY' 'IMMEDIATE' ] ;

(* 'ALTER' 'USER' *)
alter_user = 'ALTER' 'USER' role_specification [ [ 'WITH' ] alter_role_option { ',' alter_role_option } ] ;

alter_user_rename = 'ALTER' 'USER' role_name 'RENAME' 'TO' new_role_name ;

alter_user_config = 'ALTER' 'USER' ( role_specification | 'ALL' ) [ 'IN' 'DATABASE' database_name ] config_setting ;

(* 'ANALYZE' *)
analyze = 'ANALYZE' [ 'VERBOSE' ] [ table_and_columns { ',' table_and_columns } ] ;

table_and_columns = table_name [ '(' column_name { ',' column_name } ')' ] ;

(* 'BEGIN' *)
begin = 'BEGIN' [ 'TRANSACTION' | 'WORK' ] { transaction_mode } ;

(* 'CALL' *)

call_procedure = 'CALL' subprogram_name '(' [ subprogram_arg { ',' subprogram_arg } ] ')' ;

subprogram_arg = [ arg_name '=>' ] expression ;

(* 'COMMENT' *)
comment_on = 'COMMENT' 'ON' (
  'ACCESS' 'METHOD' access_method_name |
  'AGGREGATE' aggregate_name '(' aggregate_signature ')' |
  'CAST' '(' source_type 'AS' target_type ')' |
  'COLLATION' object_name |
  'COLUMN' relation_name '.' column_name |
  'CONSTRAINT' constraint_name 'ON' table_name |
  'CONSTRAINT' constraint_name 'ON' 'DOMAIN' domain_name |
  'CONVERSION' object_name |
  'DATABASE' object_name |
  'DOMAIN' object_name |
  'EXTENSION' object_name |
  'EVENT' 'TRIGGER' object_name |
  'FOREIGN' 'DATA' 'WRAPPER' object_name |
  'FOREIGN' 'TABLE' object_name |
  'FUNCTION' subprogram_name '(' [ subprogram_signature ] ')'|
  'INDEX' object_name |
  'LARGE' 'OBJECT' large_object_oid |
  'MATERIALIZED' 'VIEW' object_name |
  'OPERATOR' operator_name '(' operator_signature ')' |
  'OPERATOR' 'CLASS' object_name 'USING' index_method |
  'OPERATOR' 'FAMILY' object_name 'USING' index_method |
  'POLICY' policy_name 'ON' table_name |
  [ 'PROCEDURAL' ] 'LANGUAGE' object_name |
  'PROCEDURE' subprogram_name '(' [ subprogram_signature ] ')' |
  'PUBLICATION' object_name |
  'ROLE' object_name |
  'ROUTINE' subprogram_name '(' [ subprogram_signature ] ')' |
  'RULE' rule_name 'ON' table_name |
  'SCHEMA' object_name |
  'SEQUENCE' object_name |
  'SERVER' object_name |
  'STATISTICS' object_name |
  'SUBSCRIPTION' object_name |
  'TABLE' object_name |
  'TABLESPACE' object_name |
  'TEXT' 'SEARCH' 'CONFIGURATION' object_name |
  'TEXT' 'SEARCH' 'DICTIONARY' object_name |
  'TEXT' 'SEARCH' 'PARSER' object_name |
  'TEXT' 'SEARCH' 'TEMPLATE' object_name |
  (* 'TRANSFORM' 'FOR' type_name 'LANGUAGE' lang_name | bllewell: n/a except with implementation langauges like C *)
  'TRIGGER' trigger_name 'ON' table_name |
  'TYPE' object_name |
  'VIEW' object_name
) 'IS' ( '<Text Literal>' | 'NULL' ) ;

(* 'COMMIT' 'TRANSACTION' *)
commit = 'COMMIT' [ 'TRANSACTION' | 'WORK' ] ;

(* 'COPY' *)
copy_from = 'COPY' table_name [ '(' column_name { ',' column_name } ')' ] \
              'FROM' ( 'filename' | 'PROGRAM' 'command' | 'STDIN' )
              [ [ 'WITH' ] '(' option { ',' copy_option } ')' ] ;

copy_to = 'COPY' ( table_name [ '(' column_names ')' ] | '(' subquery ')' ) \
            'TO' ( 'filename' | 'PROGRAM' 'command' | 'STDOUT' )
            [ [ 'WITH' ] '(' option { ',' copy_option } ')' ] ;

copy_option =
  ( 'FORMAT' format_name
    | 'OIDS' [ boolean ]
    | 'FREEZE' [ boolean ]
    | 'DELIMITER' 'delimiter_character'
    | 'NULL' 'null_string'
    | 'HEADER' [ boolean ]
    | 'QUOTE' 'quote_character'
    | 'ESCAPE' 'escape_character'
    | 'FORCE_QUOTE' ( '(' column_names ')' | '*' )
    | 'FORCE_NOT_NULL' '(' column_names ')'
    | 'FORCE_NULL' '(' column_names ')'
    | 'ENCODING' 'encoding_name'
    | 'ROWS_PER_TRANSACTION' int_literal
    | 'DISABLE_FK_CHECK'
    | 'REPLACE'
    | 'SKIP' int_literal ) ;

(* 'CREATE' 'AGGREGATE' *)
create_aggregate = create_aggregate_normal
                 | create_aggregate_order_by
                 | create_aggregate_old ;

create_aggregate_normal = 'CREATE' 'AGGREGATE' aggregate_name
                          '(' ( aggregate_arg { ',' aggregate_arg } | '*' ) ')'
                          '(' 'SFUNC' '=' sfunc ',' 'STYPE' '=' state_data_type
                          { ',' aggregate_normal_option } ')' ;

create_aggregate_order_by = 'CREATE' 'AGGREGATE' aggregate_name
                            '(' [ aggregate_arg { ',' aggregate_arg } ]
                            'ORDER' 'BY' aggregate_arg { ',' aggregate_arg } ')'
                            '(' 'SFUNC' '=' sfunc ',' 'STYPE' '=' state_data_type
                            { ',' aggregate_order_by_option } ')' ;

create_aggregate_old = 'CREATE' 'AGGREGATE' aggregate_name
                       '(' 'BASETYPE' '=' base_type ','
                       'SFUNC' '=' sfunc ','
                       'STYPE' '=' state_data_type
                       { ',' aggregate_old_option } ')' ;

aggregate_arg = [ aggregate_arg_mode ] [ arg_name ] arg_type ;

aggregate_normal_option = 'SSPACE' '=' state_data_size
                        | 'FINALFUNC' '=' ffunc
                        | 'FINALFUNC_EXTRA'
                        | 'FINALFUNC_MODIFY' '=' ( 'READ_ONLY' | 'SHAREABLE' | 'READ_WRITE' )
                        | 'COMBINEFUNC' '=' combinefunc
                        | 'SERIALFUNC' '=' serialfunc
                        | 'DESERIALFUNC' '=' deserialfunc
                        | 'INITCOND' '=' initial_condition
                        | 'MSFUNC' '=' msfunc
                        | 'MINVFUNC' '=' minvfunc
                        | 'MSTYPE' '=' mstate_data_type
                        | 'MSSPACE' '=' mstate_data_size
                        | 'MFINALFUNC' '=' mffunc
                        | 'MFINALFUNC_EXTRA'
                        | 'MFINALFUNC_MODIFY' '=' ( 'READ_ONLY' | 'SHAREABLE' | 'READ_WRITE' )
                        | 'MINITCOND' '=' minitial_condition
                        | 'SORTOP' '=' sort_operator
                        | 'PARALLEL' '=' ( 'SAFE' | 'RESTRICTED' | 'UNSAFE' ) ;

aggregate_order_by_option = 'SSPACE' '=' state_data_size
                          | 'FINALFUNC' '=' ffunc
                          | 'FINALFUNC_EXTRA'
                          | 'FINALFUNC_MODIFY' '=' ( 'READ_ONLY' | 'SHAREABLE' | 'READ_WRITE' )
                          | 'INITCOND' '=' initial_condition
                          | 'PARALLEL' '=' ( 'SAFE' | 'RESTRICTED' | 'UNSAFE' )
                          | 'HYPOTHETICAL' ;

aggregate_old_option = 'SSPACE' '=' state_data_size
                     | 'FINALFUNC' '=' ffunc
                     | 'FINALFUNC_EXTRA'
                     | 'FINALFUNC_MODIFY' '=' ( 'READ_ONLY' | 'SHAREABLE' | 'READ_WRITE' )
                     | 'COMBINEFUNC' '=' combinefunc
                     | 'SERIALFUNC' '=' serialfunc
                     | 'DESERIALFUNC' '=' deserialfunc
                     | 'INITCOND' '=' initial_condition
                     | 'MSFUNC' '=' msfunc
                     | 'MINVFUNC' '=' minvfunc
                     | 'MSTYPE' '=' mstate_data_type
                     | 'MSSPACE' '=' mstate_data_size
                     | 'MFINALFUNC' '=' mffunc
                     | 'MFINALFUNC_EXTRA'
                     | 'MFINALFUNC_MODIFY' '=' ( 'READ_ONLY' | 'SHAREABLE' | 'READ_WRITE' )
                     | 'MINITCOND' '=' minitial_condition
                     | 'SORTOP' '=' sort_operator ;

(* 'CREATE' 'CAST' *)
create_cast = create_cast_with_function
            | create_cast_without_function
            | create_cast_with_inout ;

create_cast_with_function = 'CREATE' 'CAST' '(' cast_signature ')'
                            'WITH' 'FUNCTION' subprogram_name
                            [ '(' subprogram_signature ')' ]
                            [ 'AS' 'ASSIGNMENT' | 'AS' 'IMPLICIT' ] ;

create_cast_without_function = 'CREATE' 'CAST' '(' cast_signature ')'
                               'WITHOUT' 'FUNCTION'
                               [ 'AS' 'ASSIGNMENT' | 'AS' 'IMPLICIT' ] ;

create_cast_with_inout = 'CREATE' 'CAST' '(' cast_signature ')'
                         'WITH' 'INOUT'
                         [ 'AS' 'ASSIGNMENT' | 'AS' 'IMPLICIT' ] ;

cast_signature = source_type 'AS' target_type ;

(* 'CREATE' 'DATABASE' *)
create_database = 'CREATE' 'DATABASE' name [ create_database_options ] ;

create_database_options =  [ 'WITH' ] [ 'OWNER' [ '=' ] user_name ]  \
                             [ 'TEMPLATE' [ '=' ] template ]  \
                             [ 'ENCODING' [ '=' ] encoding ]  \
                             [ 'LC_COLLATE' [ '=' ] lc_collate ]  \
                             [ 'LC_CTYPE' [ '=' ] lc_ctype ]  \
                             [ 'ALLOW_CONNECTIONS' [ '=' ] allowconn ]  \
                             [ 'CONNECTION' 'LIMIT' [ '=' ] connlimit ]  \
                             [ 'IS_TEMPLATE' [ '=' ] istemplate ] \
                             [ 'COLOCATION' [ '=' ] ('true' | 'false') ] ;

create_domain = 'CREATE' 'DOMAIN' name [ 'AS' ] data_type
    [ 'DEFAULT' expression ]
    [ { domain_constraint } ] ;

domain_constraint = [ 'CONSTRAINT' constraint_name ]
    ( 'NOT' 'NULL' | 'NULL' | 'CHECK' '(' expression ')' ) ;

(* 'CREATE' 'EXTENSION' *)
create_extension = 'CREATE' 'EXTENSION' [ 'IF' 'NOT' 'EXISTS' ]
                   extension_name [ 'WITH' ]
                   [ 'SCHEMA' schema_name ]
                   [ 'VERSION' version ]
                   [ 'CASCADE' ] ;

(* 'CREATE' 'FUNCTION' *)
create_function =  'CREATE' [ 'OR' 'REPLACE' ] 'FUNCTION'
                   subprogram_name '(' [ arg_decl_with_dflt { ',' arg_decl_with_dflt } ] ')' \
                   ( 'RETURNS' data_type
                   | 'RETURNS' 'TABLE' '(' ( column_name data_type ) { ',' ( column_name data_type ) } ')' ) \
                   ( unalterable_fn_attribute | alterable_fn_only_attribute | alterable_fn_and_proc_attribute )
                   { ( unalterable_fn_attribute | alterable_fn_only_attribute | alterable_fn_and_proc_attribute ) } ;

arg_decl_with_dflt = arg_decl [ ( 'DEFAULT' | '=' ) expression ] ;

arg_decl = [ arg_name ] [ arg_mode ] arg_type;

subprogram_signature = arg_decl { ',' arg_decl } ;

fn_invocation = subprogram_name '(' [ subprogram_arg { ',' subprogram_arg } ] ')' ;

subprogram_call_signature = arg_type { ',' arg_type } ;

(* | ( 'TRANSFORM' ( 'FOR' 'TYPE' type_name ) { ',' ( 'FOR' 'TYPE' type_name ) } bllewell: n/a except with implementation langauges like C *)
unalterable_fn_attribute = 'WINDOW' | 'LANGUAGE' lang_name | 'AS' implementation_definition;

lang_name = 'SQL' | 'PLPGSQL' | 'C' ;

implementation_definition := "'" sql_stmt_list "'" |"'" plpgsql_block_stmt "'" | ( "'" obj_file"'" [ ',' "'" link_symbol "'" ] ) ;

sql_stmt_list = sql_stmt ';' { sql_stmt ';' } ;

alterable_fn_and_proc_attribute =  ( 
                      'SET' run_time_parameter ( 'TO' value | '=' value | 'FROM' 'CURRENT' )
                      | 'RESET' run_time_parameter
                      | 'RESET' 'ALL'
                      | [ 'EXTERNAL' ] 'SECURITY' ( 'INVOKER' | 'DEFINER' )
                      ) ;

alterable_fn_only_attribute =  ( volatility
                      | on_null_input
                      | 'PARALLEL' parallel_mode
                      | [ 'NOT' ] 'LEAKPROOF'
                      | 'COST' int_literal
                      | 'ROWS' int_literal
                      ) ;

volatility = ( 'IMMUTABLE' | 'STABLE' | 'VOLATILE' ) ;

on_null_input = ('CALLED' 'ON' 'NULL' 'INPUT' | 'RETURNS' 'NULL' 'ON' 'NULL' 'INPUT' | 'STRICT' ) ;

parallel_mode = ( 'UNSAFE' | 'RESTRICTED' | 'SAFE' );

(* 'CREATE' 'FOREIGN' 'DATA' 'WRAPPER' *)
create_foreign_data_wrapper = 'CREATE' 'FOREIGN' 'DATA' 'WRAPPER' fdw_name 
                              [ 'HANDLER' handler_name | 'NO' 'HANDLER' ]
                              [ 'VALIDATOR' validator_name | 'NO' 'VALIDATOR' ]
                              [ 'OPTIONS' '(' fdw_options ')' ] ;

(* 'CREATE' 'FOREIGN' 'TABLE' *)
create_foreign_table = 'CREATE' 'FOREIGN' 'TABLE' ['IF' 'NOT' 'EXISTS'] table_name
                       '(' [ foreign_table_elem { ',' foreign_table_elem } ] ')'
                       'SERVER' server_name
                       [ 'OPTIONS' '(' fdw_options ')' ] ;

foreign_table_elem = ( column_name data_type 
              [ 'OPTIONS' '(' fdw_options ')' ]
              [ 'COLLATE' collation ]
              [ column_constraint { column_constraint } ] ) | table_constraint ;

(* 'CREATE' 'GROUP' *)
create_group = 'CREATE' 'GROUP' role_name [ [ 'WITH' ] role_option { ',' role_option } ] ;

(* 'CREATE' 'INDEX' *)
create_index = 'CREATE' [ 'UNIQUE' ] 'INDEX' [ 'CONCURRENTLY' | 'NONCONCURRENTLY' ] \
               [ [ 'IF' 'NOT' 'EXISTS' ] name ] 'ON' [ 'ONLY' ] table_name \
               [ 'USING' access_method_name ]
               '(' index_elem { ',' index_elem } ')' \
               [ 'INCLUDE' '(' column_name { ',' column_name } ')' ] \
               [ 'TABLESPACE' tablespace_name ] \
               [ 'WHERE' boolean_expression ] ;

index_elem = ( column_name | '(' expression ')' ) [ operator_class_name ]
             [ 'HASH' | 'ASC' | 'DESC' ] [ 'NULLS' ( 'FIRST' | 'LAST' ) ] ;

(* 'CREATE' 'MATERIALIZED 'VIEW' *)
create_matview = 'CREATE' 'MATERIALIZED' 'VIEW' [ 'IF' 'NOT' 'EXISTS' ] \
                           matview_name [ '(' column_name { ',' column_name } ')' ] \
                           [ 'WITH' '(' storage_parameters ')' ] \
                           [ 'TABLESPACE' tablespace ] \
                           'AS' subquery [ 'WITH' [ 'NO' ] 'DATA' ] ;

(* 'CREATE' 'OPERATOR' *)
create_operator = 'CREATE' 'OPERATOR' operator_name '('
                  ( 'FUNCTION' '=' subprogram_name | 'PROCEDURE' '=' subprogram_name )
                  { ',' operator_option } ')' ;

operator_option = 'LEFTARG' '=' left_type
                | 'RIGHTARG' '=' right_type
                | 'COMMUTATOR' '=' com_op
                | 'NEGATOR' '=' neg_op
                | 'RESTRICT' '=' res_proc
                | 'JOIN' '=' join_proc
                | 'HASHES'
                | 'MERGES' ;

(* 'CREATE' 'OPERATOR' 'CLASS' *)
create_operator_class = 'CREATE' 'OPERATOR' 'CLASS' operator_class_name [ 'DEFAULT' ]
                        'FOR' 'TYPE' data_type
                        'USING' index_method 'AS' operator_class_as { ',' operator_class_as } ;

operator_class_as = 'OPERATOR' strategy_number operator_name [ '(' operator_signature ')' ]
                    [ 'FOR' 'SEARCH' ]
                  | 'FUNCTION' support_number [ '(' op_type { ',' op_type } ')' ]
                    subprogram_name '(' subprogram_signature ')'
                  | 'STORAGE' storage_type ;

(* 'CREATE' 'POLICY' *)
create_policy = 'CREATE' 'POLICY' name 'ON' table_name
                [ 'AS' ( 'PERMISSIVE' | 'RESTRICTIVE' ) ]
                [ 'FOR' ( 'ALL' | 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' ) ]
                [ 'TO' ( role_name | 'PUBLIC' | 'CURRENT_USER' | 'SESSION_USER' )
                  { ',' ( role_name | 'PUBLIC' | 'CURRENT_USER' | 'SESSION_USER' ) } ]
                [ 'USING' '(' using_expression ')' ]
                [ 'WITH' 'CHECK' '(' check_expression ')' ] ;

(* 'CREATE' 'PROCEDURE' *)
create_procedure =  'CREATE' [ 'OR' 'REPLACE' ] 'PROCEDURE'
                    subprogram_name '(' [ arg_decl_with_dflt { ',' arg_decl_with_dflt } ] ')' \
                    ( unalterable_proc_attribute | alterable_fn_and_proc_attribute )
                    { ( unalterable_proc_attribute |  alterable_fn_and_proc_attribute ) } ;

(* ( 'TRANSFORM' ( 'FOR' 'TYPE' type_name ) { ',' ( 'FOR' 'TYPE' type_name ) } bllewell: n/a except with implementation langauges like C *)
unalterable_proc_attribute = 'LANGUAGE' lang_name | 'AS' implementation_definition;

(* 'CREATE' 'RULE' *)
create_rule = 'CREATE' [ 'OR' 'REPLACE' ] 'RULE' rule_name 'AS' 'ON' rule_event
              'TO' table_name [ 'WHERE' boolean_expression ]
              'DO' [ 'ALSO' | 'INSTEAD' ]
              ( 'NOTHING'
              | command
              | '(' command { ';' command } ')' ) ;

rule_event = 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' ;

command = 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'NOTIFY' ;

(* 'CREATE' 'ROLE' *)
create_role = 'CREATE' 'ROLE' role_name [ [ 'WITH' ] role_option { ',' role_option } ] ;

role_option = 'SUPERUSER'
              | 'NOSUPERUSER'
              | 'CREATEDB'
              | 'NOCREATEDB'
              | 'CREATEROLE'
              | 'NOCREATEROLE'
              | 'INHERIT'
              | 'NOINHERIT'
              | 'LOGIN'
              | 'NOLOGIN'
              | 'CONNECTION' 'LIMIT' connlimit
              | [ 'ENCRYPTED' ] 'PASSWORD' ''' password '''
              | 'PASSWORD' 'NULL'
              | 'VALID' 'UNTIL' ''' timestamp '''
              | 'IN' 'ROLE' role_name { ',' role_name }
              | 'IN' 'GROUP' role_name { ',' role_name }
              | 'ROLE' role_name { ',' role_name }
              | 'ADMIN' role_name { ',' role_name }
              | 'USER' role_name { ',' role_name }
              | 'SYSID' uid ;

role_name = name ;
password = '<Text Literal>' ;
timestamp = '<DateTime Literal>' ;
connlimit = int_literal;
uid = '<Text Literal>';

(* 'CREATE' 'SCHEMA' *)
create_schema_name = 'CREATE' 'SCHEMA' [ 'IF' 'NOT' 'EXISTS' ] schema_name
                       [ 'AUTHORIZATION' role_specification ]
                       [ schema_element { schema_element } ] ;

create_schema_role = 'CREATE' 'SCHEMA' [ 'IF' 'NOT' 'EXISTS']
                       'AUTHORIZATION' role_specification [ schema_element { schema_element } ] ;

(* TODO add ddl_statement, dcl_statement, dml_statement as top level rules *)
schema_element = '<YSQL DDL statement>' ;

(* 'CREATE' 'SEQUENCE' *)
create_sequence = 'CREATE' [ 'TEMPORARY' | 'TEMP' ] 'SEQUENCE' [ 'IF' 'NOT' 'EXISTS' ] sequence_name  sequence_options ;

sequence_name = qualified_name ;

sequence_options = [ 'INCREMENT' [ 'BY' ] int_literal ]
                     [ 'MINVALUE' int_literal | 'NO' 'MINVALUE' ]
                     [ 'MAXVALUE' int_literal | 'NO' 'MAXVALUE' ]
                     [ 'START' [ 'WITH' ] int_literal ]
                     [ 'CACHE' positive_int_literal ]
                     [ [ 'NO' ] 'CYCLE' ] ;

(* 'CREATE' 'SERVER' *)
create_server = 'CREATE' 'SERVER' [ 'IF' 'NOT' 'EXISTS' ] server_name [ 'TYPE' server_type ]
                [ 'VERSION' server_version ] 'FOREIGN' 'DATA' 'WRAPPER' fdw_name
                [ 'OPTIONS' '(' fdw_options ')' ] ;

(* 'CREATE' 'TABLE' *)
create_table = 'CREATE' [ 'TEMPORARY' | 'TEMP' ] 'TABLE' [ 'IF' 'NOT' 'EXISTS' ] table_name
                 '(' [ table_elem { ',' table_elem } ] ')'
                 [ 'WITH' '(' ( 'COLOCATION' '=' ('true' | 'false') | storage_parameters ) ')'
                      | 'WITHOUT' 'OIDS' ] \
                 [ TABLESPACE tablespace_name ]
                 [ 'SPLIT' ( 'INTO' positive_int_literal 'TABLETS'
                      | 'AT' 'VALUES' '(' split_row { ',' split_row } ')' ) ] ;

split_row = '(' column_value { ',' column_value } ')';

table_elem = ( column_name data_type [ column_constraint { column_constraint } ] ) | table_constraint ;

column_constraint = [ 'CONSTRAINT' constraint_name ]
                      (  'NOT' 'NULL'
                         | 'NULL'
                         | 'CHECK' '(' expression ')'
                         | 'DEFAULT' expression
                         | 'UNIQUE' index_parameters
                         | 'PRIMARY' 'KEY'
                         | references_clause )
                      [ 'DEFERRABLE' | 'NOT' 'DEFERRABLE' ] [ 'INITIALLY' 'DEFERRED' | 'INITIALLY' 'IMMEDIATE' ] ;

table_constraint = [ 'CONSTRAINT' constraint_name ]
                     ( 'CHECK' '(' expression ')'
                       | 'UNIQUE' '(' column_names ')' index_parameters
                       | 'PRIMARY' 'KEY' '(' key_columns ')'
                       | 'FOREIGN' 'KEY' '(' column_names ')' references_clause )
                     [ 'DEFERRABLE' | 'NOT' 'DEFERRABLE' ] [ 'INITIALLY' 'DEFERRED' | 'INITIALLY' 'IMMEDIATE' ] ;

key_columns = hash_columns [ ',' range_columns ]
              | range_columns ;

hash_columns = column_name [ 'HASH' ]
                | '(' column_name { ',' column_name } ')' 'HASH' ;

range_columns = ( column_name ( 'ASC' | 'DESC' ) ) { ','  ( column_name ( 'ASC' | 'DESC' ) ) } ;

references_clause = 'REFERENCES' table_name [ ( column_name { ',' column_name } ) ]
                      [ 'MATCH' 'FULL' | 'MATCH' 'PARTIAL' | 'MATCH' 'SIMPLE' ] \
                      [ 'ON' 'DELETE' key_action ] [ 'ON' 'UPDATE' key_action ] ;

key_action = 'NO' 'ACTION' | 'RESTRICT' | 'CASCADE' | 'SET' 'NULL' | 'SET' 'DEFAULT' ;

storage_parameters = storage_parameter { ',' storage_parameter } ;

storage_parameter = param_name [ '=' param_value] ;

index_parameters = [ 'INCLUDE' '(' column_names ')' ]
                     [ 'WITH' '(' storage_parameters ')' ]
                     [ USING INDEX TABLESPACE tablespace_name ] ;

(* 'CREATE' 'TABLE' 'AS' *)
create_table_as = 'CREATE' [ 'TEMPORARY' | 'TEMP' ] 'TABLE' [ 'IF' 'NOT' 'EXISTS' ] \
                           table_name [ '(' column_name { ',' column_name } ')' ] \
                           'AS' subquery [ 'WITH' [ 'NO' ] 'DATA' ] ;


(* CREATE TRIGGER *)
create_trigger = 'CREATE' 'TRIGGER' name
                  ( 'BEFORE' | 'AFTER' | 'INSTEAD' 'OF' ) ( event { 'OR' event } )
                      'ON' table_name
                      [ 'FROM' table_name ] \
                      [ 'NOT' 'DEFERRABLE' ]
                      [ 'FOR' [ 'EACH' ] ( 'ROW' | 'STATEMENT' ) ]
                      [ 'WHEN' '(' boolean_expression ')' ] \
                      'EXECUTE' ( 'FUNCTION' | 'PROCEDURE' ) subprogram_name '(' [ subprogram_signature ] ')' ;

event = ( 'INSERT' | 'UPDATE' [ 'OF' column_name { ',' column_name } ] | 'DELETE' | 'TRUNCATE' ) ;

(* 'CREATE' 'TYPE' *)
create_composite_type = 'CREATE' 'TYPE' type_name 'AS'
                          '(' [ composite_type_elem { ',' composite_type_elem } ] ')' ;

create_enum_type = 'CREATE' 'TYPE' type_name 'AS' 'ENUM'
                     '(' [ label { ',' label } ] ')' ;

create_range_type = 'CREATE' 'TYPE' type_name 'AS' 'RANGE'
                      '(' 'SUBTYPE' '=' subtype { ',' range_type_option } ')' ;

create_base_type = 'CREATE' 'TYPE' type_name
                     '(' 'INPUT' '=' input_function ',' 'OUTPUT' '=' output_function
                     { ',' base_type_option } ')' ;

create_shell_type = 'CREATE' 'TYPE' type_name ;

composite_type_elem = attribute_name data_type [ 'COLLATE' collation ] ;

range_type_option = 'SUBTYPE_OPCLASS' '=' subtype_operator_class
                      | 'COLLATION' '=' collation
                      | 'CANONICAL' '=' canonical_function
                      | 'SUBTYPE_DIFF' '=' subtype_diff_function ;

base_type_option = 'RECEIVE' '=' receive_function
                     | 'SEND' '=' send_function
                     | 'TYPMOD_IN' '=' type_modifier_input_function
                     | 'TYPMOD_OUT' '=' type_modifier_output_function
                     | 'INTERNALLENGTH' '=' ( internallength | 'VARIABLE' )
                     | 'PASSEDBYVALUE'
                     | 'ALIGNMENT' '=' alignment
                     | 'STORAGE' '=' storage
                     | 'LIKE' '=' like_type
                     | 'CATEGORY' '=' category
                     | 'PREFERRED' '=' preferred
                     | 'DEFAULT' '=' default
                     | 'ELEMENT' '=' element
                     | 'DELIMITER' '=' delimiter
                     | 'COLLATABLE' '=' collatable ;

(* 'CREATE' 'USER' *)
create_user = 'CREATE' 'USER' role_name [ [ 'WITH' ] role_option { ',' role_option } ] ;

(* 'CREATE' 'USER' 'MAPPING' *)
create_user_mapping = 'CREATE' 'USER' 'MAPPING' [ 'IF' 'NOT' 'EXISTS' ] 'FOR' user
                      'SERVER' server_name
                      [ 'OPTIONS' '(' fdw_options ')' ] ;

user = ( user_name
       | 'USER'
       | 'CURRENT_USER'
       | 'PUBLIC' ) ;

(* 'CREATE' 'VIEW' *)
create_view = 'CREATE' [ 'OR' 'REPLACE' ] [ 'TEMPORARY' | 'TEMP' ] 'VIEW' qualified_name [ '(' name { ',' name } ')' ] 'AS' select ;


(* 'DEALLOCATE' *)
deallocate = 'DEALLOCATE' [ 'PREPARE' ] ( name | 'ALL' ) ;

(* 'DECLARE' *)
declare = 'DECLARE' name [ 'BINARY' ] [ 'INSENSITIVE' ] [ [ 'NO' ] 'SCROLL' ] \
          'CURSOR' [ ( 'WITH' | 'WITHOUT' ) 'HOLD' ] 'FOR' subquery ;

(* 'MOVE' *)
move = 'MOVE' [ move_to_one_row | move_over_many_rows ] [ 'FROM' | 'IN' ] name ;

move_to_one_row     =  ( 'FIRST' | 'LAST' | 'ABSOLUTE' int_literal |
                         'NEXT' | 'FORWARD' | 'PRIOR' | 'BACKWARD' | 'RELATIVE' int_literal ) ;

move_over_many_rows =  ( 'ALL' | 'FORWARD' 'ALL' | 'FORWARD' int_literal | int_literal |
                         'BACKWARD' 'ALL' | 'BACKWARD' int_literal ) ;

(* 'FETCH' *)
fetch = 'FETCH' [ fetch_one_row | fetch_many_rows ] [ 'FROM' | 'IN' ] name ;

fetch_one_row   =  ( 'FIRST' | 'LAST' | 'ABSOLUTE' int_literal |
                     'NEXT' | 'FORWARD' | 'PRIOR' | 'BACKWARD' | 'RELATIVE' int_literal ) ;

fetch_many_rows =  ( 'ALL' | 'FORWARD' 'ALL' | 'FORWARD' int_literal | int_literal |
                     'BACKWARD' 'ALL' | 'BACKWARD' int_literal ) ;

(* 'CLOSE' *)
close = 'CLOSE' ( name | 'ALL' ) ;

(* 'DELETE' *)
delete = [ 'WITH' [ 'RECURSIVE' ] ( common_table_expression { ',' common_table_expression } ) ] \
       'DELETE' 'FROM' table_expr [ [ 'AS' ] alias ] \
       [ 'WHERE' boolean_expression | 'WHERE' 'CURRENT' 'OF' cursor_name ] \
       [ returning_clause ] ;

returning_clause = 'RETURNING' ( '*' | ( output_expression [ [ 'AS' ] output_name ] )
                                         { ',' ( output_expression [ [ 'AS' ] output_name ] ) } ) ;

returning_expression = output_expression [ [ 'AS' ] output_name ] ;

(* 'DO' *)
do = 'DO' "'" plpgsql_block_stmt "'";

(* 'DROP' 'AGGREGATE' *)
drop_aggregate = 'DROP' 'AGGREGATE' [ 'IF' 'EXISTS' ] ( aggregate_name '(' aggregate_signature ')' )
                 { ',' ( aggregate_name '(' aggregate_signature ')' ) }
                 [ 'CASCADE' | 'RESTRICT' ] ;

aggregate_signature = '*'
                    | aggregate_arg { ',' aggregate_arg }
                    | [ aggregate_arg { ',' aggregate_arg } ]
                      'ORDER' 'BY' aggregate_arg { ',' aggregate_arg } ;

(* 'DROP' 'CAST' *)
drop_cast = 'DROP' 'CAST' [ 'IF' 'EXISTS' ] '(' cast_signature ')' [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'DATABASE' *)
drop_database = 'DROP' 'DATABASE' [ 'IF' 'EXISTS' ] database_name ;

(* 'DROP' 'SCHEMA' *)
drop_schema = 'DROP' 'SCHEMA' [ 'IF' 'EXISTS' ] schema_name { ',' schema_name } [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'DOMAIN' *)
drop_domain = 'DROP' 'DOMAIN' [ 'IF' 'EXISTS' ] name { ',' name }  [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'EXTENSION' *)
drop_extension = 'DROP' 'EXTENSION' [ 'IF' 'EXISTS' ]
                 extension_name { ',' extension_name }
                 [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'FOREIGN' 'DATA' 'WRAPPER' *)
drop_foreign_data_wrapper = 'DROP' 'FOREIGN' 'DATA' 'WRAPPER' [ 'IF' 'EXISTS' ] fdw_name
                            [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'FOREIGN' 'TABLE' *)
drop_foreign_table = 'DROP' 'FOREIGN' 'TABLE' [ 'IF' 'EXISTS' ] table_name
                     [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'FUNCTION' *)
drop_function = 'DROP' 'FUNCTION' [ 'IF' 'EXISTS' ] \
                        ( subprogram_name '(' [ subprogram_signature ] ')' )
                  { ',' ( subprogram_name '(' [ subprogram_signature ] ')' ) }
                  [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'GROUP' *)
drop_group = 'DROP' 'GROUP' [ 'IF' 'EXISTS' ] role_name { ',' role_name } ;

(* 'DROP' 'MATERIALIZED' 'VIEW' *)
drop_matview = 'DROP' 'MATERIALIZED' 'VIEW' [ 'IF' 'EXISTS' ] matview_name \
               [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'OPERATOR' *)
drop_operator = 'DROP' 'OPERATOR' [ 'IF' 'EXISTS' ] ( operator_name '(' operator_signature ')' )
                { ',' ( operator_name '(' operator_signature ')' ) }
                [ 'CASCADE' | 'RESTRICT' ] ;

operator_signature = ( left_type | 'NONE' ) ',' ( right_type | 'NONE' ) ;

(* 'DROP' 'OPERATOR' 'CLASS' *)
drop_operator_class = 'DROP' 'OPERATOR' 'CLASS' [ 'IF' 'EXISTS' ] operator_class_name
                      'USING' index_method [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'POLICY' *)
drop_policy = 'DROP' 'POLICY' [ 'IF' 'EXISTS' ] name 'ON' table_name [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'PROCEDURE' *)
drop_procedure = 'DROP' 'PROCEDURE' [ 'IF' 'EXISTS' ] \
                        ( subprogram_name '(' [ subprogram_signature ] ')' )
                  { ',' ( subprogram_name '(' [ subprogram_signature ] ')' ) }
                  [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'ROLE' *)
drop_role = 'DROP' 'ROLE' [ 'IF' 'EXISTS' ] role_name { ',' role_name } ;

(* 'DROP' 'RULE' *)
drop_rule = 'DROP' 'RULE' [ 'IF' 'EXISTS' ] rule_name 'ON' table_name [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'SEQUENCE' *)
drop_sequence = 'DROP' 'SEQUENCE' [ 'IF' 'EXISTS' ] sequence_name [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'OWNED' *)
drop_owned = 'DROP' 'OWNED' 'BY' role_specification { ',' role_specification }
            [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'SERVER' *)
drop_server = 'DROP' 'SERVER' [ 'IF' 'EXISTS' ] server_name [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'TABLE' *)
drop_table = 'DROP' 'TABLE' [ 'IF' 'EXISTS' ] table_name { ',' table_name}
                  [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'INDEX' *)
drop_index = 'DROP' 'INDEX' [ 'IF' 'EXISTS' ] index_name [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'TYPE' *)
drop_type = 'DROP' 'TYPE' [ 'IF' 'EXISTS' ] type_name { ',' type_name }
              [ 'CASCADE' | 'RESTRICT' ] ;

(* 'DROP' 'USER' *)
drop_user = 'DROP' 'USER' [ 'IF' 'EXISTS' ] role_name { ',' role_name } ;

(* 'DROP' 'TRIGGER' *)
drop_trigger = 'DROP' 'TRIGGER' [ 'IF' 'EXISTS' ] name 'ON' table_name [ 'CASCADE' | 'RESTRICT' ] ;

(* 'END' 'TRANSACTION' *)
end = 'END' [ 'TRANSACTION' | 'WORK' ] ;

(* 'EXECUTE' *)
execute_statement = 'EXECUTE' name [ '(' expression { ',' expression } ')' ] ;

(* 'EXPLAIN' *)
explain := 'EXPLAIN' [ ( [ 'ANALYZE' ] [ 'VERBOSE' ] ) | '(' option { ',' option } ')' ] sql_stmt ;

option = 'ANALYZE' [ boolean ]
           | 'VERBOSE' [ boolean ]
           | 'COSTS' [ boolean ]
           | 'BUFFERS' [ boolean ]
           | 'TIMING' [ boolean ]
           | 'SUMMARY' [ boolean ]
           | 'FORMAT' ( 'TEXT' | 'XML' | 'JSON' | 'YAML' ) ;

(* 'GRANT' *)
grant_table = 'GRANT' ( ( 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'TRUNCATE' | 'REFERENCES' | 'TRIGGER' )
    { ',' ( 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'TRUNCATE' | 'REFERENCES' | 'TRIGGER' ) }
     | 'ALL' [ 'PRIVILEGES' ] )
    'ON' ( [ 'TABLE' ] table_name { ',' table_name }
         | 'ALL' 'TABLES' 'IN' 'SCHEMA' schema_name { ',' schema_name } )
    'TO' grant_role_spec { ',' grant_role_spec } [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_table_col = 'GRANT' ( ( 'SELECT' | 'INSERT' | 'UPDATE' | 'REFERENCES' ) '(' column_names ')'
    { ',' '(' column_names ')' }
     | 'ALL' [ 'PRIVILEGES' ] '(' column_names ')' )
    'ON' ( [ 'TABLE' ] table_name { ',' table_name } )
    'TO' grant_role_spec { ',' grant_role_spec } [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_seq = 'GRANT' ( ( 'USAGE' | 'SELECT' | 'UPDATE' ) { ',' ( 'USAGE' | 'SELECT' | 'UPDATE' ) }
     | 'ALL' [ 'PRIVILEGES' ] )
    'ON' ( 'SEQUENCE' sequence_name { ',' sequence_name }
         | 'ALL' 'SEQUENCES' 'IN' 'SCHEMA' schema_name { ',' sequence_name } )
    'TO' grant_role_spec { ',' grant_role_spec } [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_db = 'GRANT' ( ( 'CREATE' | 'CONNECT' | 'TEMPORARY' | 'TEMP' ) { ',' ( 'CREATE' | 'CONNECT' | 'TEMPORARY' | 'TEMP' ) }
    | 'ALL' [ 'PRIVILEGES' ] )
    'ON' 'DATABASE' database_name { ',' database_name }
    'TO' grant_role_spec { ',' grant_role_spec } [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_domain = 'GRANT' ( 'USAGE' | 'ALL' [ 'PRIVILEGES' ] )
    'ON' 'DOMAIN' domain_name { ',' domain_name }
    'TO' grant_role_spec { ',' grant_role_spec } [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_schema = 'GRANT' ( ( 'CREATE' | 'USAGE' ) { ',' ( 'CREATE' | 'USAGE' ) } | 'ALL' [ 'PRIVILEGES' ] )
    'ON' 'SCHEMA' schema_name { ',' schema_name }
    'TO' grant_role_spec { ',' grant_role_spec } [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_type = 'GRANT' ( 'USAGE' | 'ALL' [ 'PRIVILEGES' ] )
    'ON' 'TYPE' type_name { ',' type_name }
    'TO' grant_role_spec { ',' grant_role_spec } [ 'WITH' 'GRANT' 'OPTION' ] ;

grant_role = 'GRANT' role_name { ',' role_name } 'TO' role_name { ',' role_name }
      [ 'WITH' 'ADMIN' 'OPTION' ] ;

grant_role_spec = [ 'GROUP' ] role_name
  | 'PUBLIC'
  | 'CURRENT_USER'
  | 'SESSION_USER' ;

(* 'IMPORT' 'FOREIGN' 'SCHEMA' *)
import_foreign_schema = 'IMPORT' 'FOREIGN' 'SCHEMA' remote_schema
                        [ ( 'LIMIT' 'TO' | 'EXCEPT' ) '(' table_name {, table_name} ')' ]
                        'FROM' 'SERVER' server_name
                        'INTO' local_schema
                        [ 'OPTIONS' '(' fdw_options ')' ] ;
                        
remote_schema = '<Text Literal>' ;

local_schema = '<Text Literal>' ;

(* 'INSERT' *)

insert = [ 'WITH' [ 'RECURSIVE' ] ( common_table_expression { ',' common_table_expression } ) ] \
           'INSERT' 'INTO' table_name [ 'AS' alias ] [ '(' column_names ')' ] \
               ( ( 'DEFAULT' 'VALUES' )
               | 'VALUES' '(' column_values ')' { ',' '(' column_values ')' }
               | subquery ) \
               [ 'ON' 'CONFLICT' [ conflict_target ] conflict_action ] \
               [ returning_clause ] ;

subquery = select | values ;

column_values = ( expression | 'DEFAULT' ) { ',' ( expression | 'DEFAULT' ) } ;


conflict_target = '(' ( column_name | expression ) { ',' ( column_name | expression ) } ')'  [ 'WHERE' boolean_expression ] | 'ON' 'CONSTRAINT' constraint_name ;

conflict_action = 'DO' 'NOTHING' | 'DO' 'UPDATE' 'SET' update_item { ',' update_item } [ 'WHERE' boolean_expression ] ;


(* 'LOCK' *)
lock_table = 'LOCK' [ 'TABLE' ]
                      ( ( table_expr ) { ',' ( table_expr ) } )
                      [ 'IN' lockmode 'MODE' ] [ 'NOWAIT' ] ;

lockmode = ( 'ACCESS' 'SHARE'
               | 'ROW' 'SHARE'
               | 'ROW' 'EXCLUSIVE'
               | 'SHARE' 'UPDATE' 'EXCLUSIVE'
               | 'SHARE'
               | 'SHARE' 'ROW' 'EXCLUSIVE'
               | 'EXCLUSIVE'
               | 'ACCESS' 'EXCLUSIVE' ) ;

(* 'PREPARE' *)
prepare_statement = 'PREPARE' name [ '(' data_type { ',' data_type } ')' ] 'AS' subquery ;

(* 'REASSIGN' 'OWNED' *)
reassign_owned = 'REASSIGN' 'OWNED' 'BY' role_specification { ',' role_specification }
                                    'TO' role_specification ;

(* 'REFRESH' 'MATERIALIZED' 'VIEW' *)
refresh_matview = 'REFRESH' 'MATERIALIZED' 'VIEW' [ 'CONCURRENTLY' ] \
                  matview_name [ 'WITH' [ 'NO' ] 'DATA' ] ;

(* 'RESET' *)
reset_stmt := 'RESET' ( run_time_parameter | 'ALL' ) ;

(* 'RESET' 'ROLE' *)
reset_role = 'RESET' 'ROLE' ;

(* 'RESET' 'SESSION' 'AUTHORIZATION' *)
reset_session_authorization = 'RESET' 'SESSION' 'AUTHORIZATION' ;

(* 'REVOKE' *)
revoke_table = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                     ( ( 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'TRUNCATE' | 'REFERENCES' | 'TRIGGER' )
                     { ',' ( 'SELECT' | 'INSERT' | 'UPDATE' | 'DELETE' | 'TRUNCATE' | 'REFERENCES' | 'TRIGGER' ) }
                      | 'ALL' [ 'PRIVILEGES' ] )
                     'ON' ( [ 'TABLE' ] table_name { ',' table_name }
                          | 'ALL' 'TABLES' 'IN' 'SCHEMA' schema_name { ',' schema_name } )
                     'FROM' ( [ 'GROUP' ] role_name | 'PUBLIC' ) { ',' ( [ 'GROUP' ] role_name | 'PUBLIC' ) }
                     [ 'CASCADE' | 'RESTRICT' ] ;

revoke_table_col = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                         ( ( 'SELECT' | 'INSERT' | 'UPDATE' | 'REFERENCES' ) '(' column_names ')'
                         { ',' '(' column_names ')' } | 'ALL' [ 'PRIVILEGES' ] '(' column_names ')' )
                         'ON' [ 'TABLE' ] table_name { ',' table_name }
                         'FROM' ( [ 'GROUP' ] role_name | 'PUBLIC' ) { ',' ( [ 'GROUP' ] role_name | 'PUBLIC' ) }
                         [ 'CASCADE' | 'RESTRICT' ] ;

revoke_seq = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                   ( ( 'USAGE' | 'SELECT' | 'UPDATE' ) { ',' ( 'USAGE' | 'SELECT' | 'UPDATE' ) }
                    | 'ALL' [ 'PRIVILEGES' ] )
                   'ON' ( 'SEQUENCE' sequence_name { ',' sequence_name }
                        | 'ALL' 'SEQUENCES' 'IN' 'SCHEMA' schema_name { ',' schema_name } )
                   'FROM' ( [ 'GROUP' ] role_name | 'PUBLIC' ) { ',' ( [ 'GROUP' ] role_name | 'PUBLIC' ) }
                   [ 'CASCADE' | 'RESTRICT' ] ;

revoke_db = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                  ( ( 'CREATE' | 'CONNECT' | 'TEMPORARY' | 'TEMP' ) { ',' ( 'CREATE' | 'CONNECT' | 'TEMPORARY' | 'TEMP' ) }
                   | 'ALL' [ 'PRIVILEGES' ] )
                  'ON' 'DATABASE' database_name { ',' database_name }
                  'FROM' ( [ 'GROUP' ] role_name | 'PUBLIC' ) { ',' ( [ 'GROUP' ] role_name | 'PUBLIC' ) }
                  [ 'CASCADE' | 'RESTRICT' ] ;

revoke_domain = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                      ( 'USAGE' | 'ALL' [ 'PRIVILEGES' ] )
                      'ON' 'DOMAIN' domain_name { ',' domain_name }
                      'FROM' ( [ 'GROUP' ] role_name | 'PUBLIC' ) { ',' ( [ 'GROUP' ] role_name | 'PUBLIC' ) }
                      [ 'CASCADE' | 'RESTRICT' ] ;

revoke_schema = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                      ( ( 'CREATE' | 'USAGE' ) { ',' ( 'CREATE' | 'USAGE' ) } | 'ALL' [ 'PRIVILEGES' ] )
                      'ON' 'SCHEMA' schema_name { ',' schema_name }
                      'FROM' ( [ 'GROUP' ] role_name | 'PUBLIC' ) { ',' ( [ 'GROUP' ] role_name | 'PUBLIC' ) }
                      [ 'CASCADE' | 'RESTRICT' ] ;

revoke_type = 'REVOKE' [ 'GRANT' 'OPTION' 'FOR' ]
                    ( 'USAGE' | 'ALL' [ 'PRIVILEGES' ] )
                    'ON' 'TYPE' type_name { ',' type_name }
                    'FROM' ( [ 'GROUP' ] role_name | 'PUBLIC' ) { ',' ( [ 'GROUP' ] role_name | 'PUBLIC' ) }
                    [ 'CASCADE' | 'RESTRICT' ] ;

revoke_role = 'REVOKE' [ 'ADMIN' 'OPTION' 'FOR' ]
                    role_name { ',' role_name } 'FROM' role_name { ',' role_name }
                    [ 'CASCADE' | 'RESTRICT' ] ;

(* 'ROLLBACK' *)
rollback = 'ROLLBACK' [ 'TRANSACTION' | 'WORK' ] ;

(* 'SELECT' *)
select = [ 'WITH' [ 'RECURSIVE' ] ( common_table_expression { ',' common_table_expression } ) ] \
           'SELECT' [ 'ALL' | 'DISTINCT' [ 'ON' ( '(' expression { ',' expression } ')' ) ] ]
               [ '*' | ( ( ( expression | fn_over_window | ordinary_aggregate_fn_invocation | within_group_aggregate_fn_invocation ) [ [ 'AS' ] name ] )
                         { ',' ( ( expression | fn_over_window | ordinary_aggregate_fn_invocation | within_group_aggregate_fn_invocation ) [ [ 'AS' ] name ] ) } ) ] \
               [ 'FROM' ( from_item { ','  from_item } ) ] \
               [ 'WHERE' boolean_expression ] \
               [ 'GROUP' 'BY' ( grouping_element { ',' grouping_element } ) ] \
               [ 'HAVING' ( boolean_expression ) ] \
               [ 'WINDOW' ( ( name 'AS' window_definition ) { ',' ( name 'AS' window_definition ) } ) ] \
               [ ( 'UNION' | 'INTERSECT' | 'EXCEPT' ) [ 'ALL' | 'DISTINCT' ] select ] \
               [ 'ORDER' 'BY' ( order_expr { ',' order_expr } ) ] \
               [ 'LIMIT' ( int_expression | 'ALL' ) ] \
               [ 'OFFSET' int_expression [ 'ROW' | 'ROWS' ] ] \
               [ 'FETCH' ( FIRST | NEXT ) int_expression ( ROW | ROWS ) ONLY ] \
               { 'FOR' ( 'UPDATE' | 'NO KEY UPDATE' | 'SHARE' | 'KEY SHARE' ) [ 'OF' table_name { ',' table_name} ] [ 'NOWAIT' | 'SKIP LOCKED' ] };

with_clause = [ 'WITH' [ 'RECURSIVE' ] ( common_table_expression { ',' common_table_expression } ) ] ;

common_table_expression = name [ '(' name { ',' name } ')' ] 'AS' '(' ( select | values | insert | update | delete ) ')' ;

select_expression = expression [ [ 'AS' ] name ] ;

order_expr = expression [ 'ASC' | 'DESC' | 'USING' operator_name ]
             [ 'NULLS' ( 'FIRST' | 'LAST' ) ] ;

(* 'SET' variable *)
set = 'SET' [ 'SESSION' | 'LOCAL' ]
        ( run_time_parameter ( 'TO' | '=' ) ( value | 'DEFAULT' )
          | 'TIME' 'ZONE' ( timezone | 'LOCAL' | 'DEFAULT' ) ) ;

(* 'SET' 'CONSTRAINTS' *)
set_constraints = 'SET' 'CONSTRAINTS' ( 'ALL' | name { ',' name } ) ( 'DEFERRED' | 'IMMEDIATE' ) ;

(* 'SET' 'ROLE' *)
set_role = 'SET' [ 'SESSION' | 'LOCAL' ] 'ROLE' ( role_name | 'NONE' ) ;

(* 'SET' 'SESSION' 'AUTHORIZATION' *)
set_session_authorization = 'SET' [ 'SESSION' | 'LOCAL' ] 'SESSION' 'AUTHORIZATION' ( role_name | 'DEFAULT' ) ;

(* 'SET' 'TRANSACTION' *)
set_transaction = 'SET' 'TRANSACTION' transaction_mode { transaction_mode } ;

transaction_mode = isolation_level
                     | read_write_mode
                     | deferrable_mode ;

isolation_level = 'ISOLATION' 'LEVEL' ( 'READ' 'UNCOMMITTED'
                                       | 'READ' 'COMMITTED'
                                       | 'REPEATABLE' 'READ'
                                       | 'SERIALIZABLE' );

read_write_mode = 'READ' 'ONLY' | 'READ' 'WRITE' ;

deferrable_mode = [ 'NOT' ] 'DEFERRABLE' ;

(* 'SHOW' variable *)
show_stmt = 'SHOW' ( run_time_parameter | 'ALL' ) ;

(* 'SHOW' 'TRANSACTION' *)
show_transaction = 'SHOW' 'TRANSACTION' 'ISOLATION' 'LEVEL' ;

(* 'START' 'TRANSACTION' *)
start_transaction = 'START' 'TRANSACTION' { transaction_mode } ;

(* 'TRUNCATE' *)

truncate = 'TRUNCATE' [ 'TABLE' ] ( table_expr { ',' table_expr } ) [ 'CASCADE' | 'RESTRICT' ];

table_expr = [ 'ONLY' ] table_name [ '*' ] ;

(* 'UPDATE' *)
update = [ 'WITH' [ 'RECURSIVE' ] ( common_table_expression { ',' common_table_expression } ) ] \
       'UPDATE' table_expr [ [ 'AS' ] alias ] \
       'SET' update_item { ',' update_item }
       (* [ 'FROM' from_list ] \ *)
       [ 'WHERE' boolean_expression | 'WHERE' 'CURRENT' 'OF' cursor_name ] \
       [ returning_clause ] ;

update_item = ( column_name '=' column_value
                  | '(' column_names ')' '=' [ 'ROW' ] '(' column_values ')'
                  | '(' column_names ')' '=' '(' subquery ')' ) ;

column_value = expression | 'DEFAULT' ;

(* 'VALUES' *)
values = 'VALUES' '(' expression_list ')' { ',' '(' expression_list ')' } \
            [ 'ORDER' 'BY' ( order_expr { ',' order_expr } ) ] \
            [ 'LIMIT' ( int_expression | 'ALL' ) ] \
            [ 'OFFSET' int_expression [ 'ROW' | 'ROWS' ] ] \
            [ 'FETCH' ( FIRST | NEXT ) int_expression ( ROW | ROWS ) ONLY ] ;

expression_list = expression { ',' expression } ;


(* For the invocation of a window function, or an aggregate function, in conjunction with the OVER keyword.*)
(* And for the invocation of an aggregate function, in conjunction with the GROUP BY clause.*)

select_start = 'SELECT' [ 'ALL' | 'DISTINCT' [ 'ON' ( '(' expression { ',' expression } ')' ) ] ]
                   [ '*' | ( ( ( expression | fn_over_window | ordinary_aggregate_fn_invocation | within_group_aggregate_fn_invocation ) [ [ 'AS' ] name ] )
                             { ',' ( ( expression | fn_over_window | ordinary_aggregate_fn_invocation | within_group_aggregate_fn_invocation ) [ [ 'AS' ] name ] ) } ) ] ;

fn_over_window = name \
    '(' [ expression { ',' expression } | '*' ] \
    [ 'FILTER' '(' 'WHERE' ( boolean_expression ) ')' ] 'OVER' ( window_definition | name ) ;

ordinary_aggregate_fn_invocation = name \
    '(' ( ( [ 'ALL' | 'DISTINCT' ] expression { ',' expression } ) | '*' )
    [ 'ORDER' 'BY' order_expr { ',' order_expr } ] ')' \
    [ 'FILTER' '(' 'WHERE' boolean_expression ')' ] ;

within_group_aggregate_fn_invocation =  name \
    '(' ( expression { ',' expression } ) ')' \
    'WITHIN' 'GROUP' '(' 'ORDER' 'BY' order_expr { ',' order_expr } ')' \
    [ 'FILTER' '(' 'WHERE' boolean_expression ')' ] ;

window_clause :=
  'WINDOW' ( ( name 'AS' window_definition ) { ',' ( name 'AS' window_definition ) } ) ;

window_definition =
  '(' [ name ] \
      [ 'PARTITION' 'BY' order_expr { ',' order_expr } ] \
      [ 'ORDER' 'BY' order_expr { ',' order_expr } ] \
      [ frame_clause ] ')' ;

frame_clause =
  [ ( 'RANGE' | 'ROWS' | 'GROUPS' ) frame_bounds ] [ frame_exclusion ] ;

frame_bounds =
  ( frame_start | 'BETWEEN' frame_start 'AND' frame_end ) ;

frame_start = frame_bound ;

frame_end = frame_bound ;

frame_bound =
  ( 'UNBOUNDED' 'PRECEDING' |
    offset 'PRECEDING' |
    'CURRENT' 'ROW' |
    offset 'FOLLOWING' |
    'UNBOUNDED' 'FOLLOWING' ) ;

frame_exclusion =
  ( 'EXCLUDE' 'CURRENT' 'ROW' |
    'EXCLUDE' 'GROUP' |
    'EXCLUDE' 'TIES' |
    'EXCLUDE' 'NO' 'OTHERS' ) ;

offset = ( integer_expression | numeric_expression | interval_expression ) ;

group_by_clause = 'GROUP' 'BY' ( grouping_element { ',' grouping_element } ) ;

grouping_element = '(' ')' | '(' expression { ',' expression } ')' | 'ROLLUP' '(' expression { ',' expression } ')' | 'CUBE' '(' expression { ',' expression } ')' | 'GROUPING' 'SETS' '(' grouping_element { ',' grouping_element } ')' ;

having_clause = 'HAVING' ( boolean_expression ) ;

(* Supporting rules *)
qualified_name = [ [ database_name '.' ] schema_name '.' ] name ;
role_name = name ;
database_name = name ;
schema_name = name ;
table_name = qualified_name ;
column_name = name ;
object_name = name ;
access_method_name = name ;
relation_name = qualified_name ;
aggregate_name = qualified_name ;
constraint_name = qualified_name ;
operator_name = qualified_name ;
policy_name = qualified_name ;
subprogram_name = qualified_name ;
rule_name = qualified_name ;
trigger_name = qualified_name ;

domain_name = qualified_name ;

index_method = '<Text Literal>';

arg_mode = ( 'IN' | 'OUT' | 'INOUT' | 'VARIADIC' ) ;

arg_name = name ;

arg_type = type_name ;

text_literal = '<Text Literal>' ;

int_expression = '<Integer Expression>' ;
int_literal = '<Integer Literal>' ;
positive_int_literal = '<Positive Integer Literal>' ;
non_neg_int_literal = '<Non-negative Integer Literal>' ;

numeric_literal = '<Numeric Literal>' ;

value = text_literal | numeric_literal | boolean ;

run_time_parameter = text_literal ;

large_object_oid = int_literal ;

left_type = ( qualified_name | 'NONE' ) ;
right_type = ( qualified_name | 'NONE' ) ;

lang_name = name ;

name = '<Text Literal>' ;

column_names = column_name { ',' column_name } ;

expression = '<expression>' ;

boolean = 'TRUE' | 'FALSE' ;

(* TODO(jason): change the below when issue #1557 is closed or closing *)
collation = ( '"default"' | '"C"' | '"POSIX"' | '"ucs_basic"' ) ;
type_name = qualified_name ;
attribute_name = '<Text Literal>' ;
data_type = type_name ;
label = '<Text Literal>' ;
subtype = type_name ;
operator_class_name = qualified_name ;
subtype_operator_class = operator_class_name ;
canonical_function = subprogram_name ;
subtype_diff_function = subprogram_name ;
input_function = subprogram_name ;
output_function = subprogram_name ;
receive_function = subprogram_name ;
send_function = subprogram_name ;
type_modifier_input_function = subprogram_name ;
type_modifier_output_function = subprogram_name ;
internallength = ( '-2' | '-1' | non_neg_int_literal ) ;
alignment = ( 'CHAR' | 'INT2' | 'INT4' | 'DOUBLE' ) ;
storage = ( 'PLAIN' | 'EXTERNAL' | 'EXTENDED' | 'MAIN' ) ;
like_type = type_name ;
category = '<character>' ;
preferred = boolean ;
default = '<type value>' ;
element = type_name ;
delimiter = '<character>' ;
collatable = boolean ;
param_name = '<Text Literal>' ;
param_value = '<Text Literal>' ;
code = '<Text Literal>' ;
aggregate_arg_mode = 'IN' | 'VARIADIC' ;
sfunc = subprogram_name ;
state_data_type = type_name ;
base_type = type_name ;
state_data_size = non_neg_int_literal ;
ffunc = subprogram_name ;
combinefunc = subprogram_name ;
serialfunc = subprogram_name ;
deserialfunc = subprogram_name ;
initial_condition = '<Text Literal>' ;
msfunc = subprogram_name ;
minvfunc = subprogram_name ;
mstate_data_type = type_name ;
mstate_data_size = non_neg_int_literal ;
mffunc = subprogram_name ;
minitial_condition = '<Text literal>' ;
sort_operator = operator_name ;
source_type = type_name ;
target_type = type_name ;
com_op = operator_name ;
neg_op = operator_name ;
res_proc = subprogram_name ;
join_proc = subprogram_name ;
strategy_number = positive_int_literal ;
support_number = positive_int_literal ;
op_type = data_type ;
storage_type = data_type ;
using_expression = expression ;
check_expression = expression ;
new_name = name ;
version = '<text literal>' ;
extension_name = name ;

matview_name = qualified_name ;

new_owner = qualified_name ;
alter_fdw_options = ('ADD' | 'SET' | 'DROP' ) option_name [ option_value ] { ',' alter_option } ;
fdw_name = '<Text Literal>' ;
handler_name = '<Text Literal>' ;
validator_name = '<DateTime Literal>' ;
fdw_options = option_name option_value { ',' fdw_options } ;
option_name = int_literal;
option_value = '<Text Literal>';

(*
  Notice that the "demo-2" rule uses ( ... ) redundantly.
  The two rules are semantically identical but they produce the different diagrams.
  The diagrams do express the same meaning but they are drawn using different conventions.
  Uncomment the two rule definitions and look at the end of the grammar diagrams file to
  see the two semantically equivalent, but differently drawn, diagrams.

  Make sure that you comment these out again before creating a Pull request.
*)

(*
demo-1-irrelevant-for-ysql-syntax = ( a 'K' b { ',' a 'K' b } ) ;

demo-2-irrelevant-for-ysql-syntax = ( ( a 'K' b ) { ',' ( a 'K' b ) } ) ;
*)

(* 'SAVEPOINTS' *)
savepoint_create := ( 'SAVEPOINT' name ) ;

savepoint_release := ( 'RELEASE' [ 'SAVEPOINT' ] name ) ;

savepoint_rollback := ( 'ROLLBACK' ['WORK' | 'TRANSACTION' ] 'TO' [ 'SAVEPOINT' ] name ) ;

(* -------------------------------------------------------------------------------------------------------------------------------------- *)
(* PL/pgSQL language *)

(* bllewell W.i.P. Not harmful to expose just on the "Grammar Diagrams" page *)

plpgsql_block_stmt = [ '<<' name '>>' ] \
                     [ plpgsql_declaration_section ] \
                     plpgsql_executable_section \
                     [ plpgsql_exception_section ] 'END' [name] ';' ;

plpgsql_declaration_section = 'DECLARE' [ plpgsql_declaration { plpgsql_declaration } ] ;

plpgsql_declaration = ( plpgsql_regular_declaration | plpgsql_bound_refcursor_declaration );

plpgsql_regular_declaration = [name] [ 'CONSTANT' ] [data_type] ['NOT' 'NULL' ]  [ ':=' expression ] ';' ;

plpgsql_bound_refcursor_declaration = name 'CURSOR' [ '(' data_type { ',' data_type } ')' ] 'FOR' subquery ';' ;

plpgsql_executable_section = 'BEGIN' [ plpgsql_stmt { plpgsql_stmt } ] ;

plpgsql_stmt = ( plpgsql_basic_stmt | plpgsql_compound_stmt ) ;

plpgsql_basic_stmt := (
    'NULL' | 
    plpgsql_assignment_stmt |
    plpgsql_assert_stmt     |
    static_sql_stmt         |
    dynamic_sql_stmt        |
    perform_stmt            |
    exit_stmt               |
    continue_stmt           |
    open_cursor_stmt        |
    move_in_cursor_stmt     |
    fetch_from_cursor_stmt  |
    close_cursor_stmt       |
    raise_stmt              |
    get_diagnostics_stmt    |
    return_stmt
  ) ';' ;

plpgsql_compound_stmt = ( plpgsql_block_stmt | plpgsql_loop_stmt | plpgsql_if_stmt | plpgsql_case_stmt ) ';' ;

plpgsql_exception_section = 'EXCEPTION' ( plpgsql_handler { plpgsql_handler } ) ;

plpgsql_handler = 'WHEN' ( name | 'OTHERS' ) 'THEN' ( plpgsql_stmt { plpgsql_stmt } ) ;

