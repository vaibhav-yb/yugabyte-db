// Copyright (c) YugabyteDB, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.  You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License
// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
// or implied.  See the License for the specific language governing permissions and limitations
// under the License.
//

#include "yb/util/symbolize.h"

#ifdef __linux__
#include <backtrace.h>
#endif // __linux__

#include <string>
#include <thread>

#include "yb/util/flags.h"
#include "yb/util/stack_trace.h"
#include "yb/util/libbacktrace_util.h"

// A hack to grab a couple of useful functions from glog.
// TODO: consider switching to the corresponding functions from Abseil.
namespace google {

extern int GetStackTrace(void** result, int max_depth, int skip_count);

// Symbolizes a program counter.  On success, returns true and write the
// symbol name to "out".  The symbol name is demangled if possible
// (supports symbols generated by GCC 3.x or newer).  Otherwise,
// returns false.
bool Symbolize(void *pc, char *out, int out_size);

} // namespace google

namespace yb {

namespace {

bool IsDoubleUnderscoredAndInList(
    const char* symbol, const std::initializer_list<const char*>& list) {
  if (symbol[0] != '_' || symbol[1] != '_') {
    return false;
  }
  for (const auto* idle_function : list) {
    if (!strcmp(symbol, idle_function)) {
      return true;
    }
  }
  return false;
}

bool IsIdle(const char* symbol) {
  return IsDoubleUnderscoredAndInList(symbol,
                                      { "__GI_epoll_wait",
                                        "__pthread_cond_timedwait",
                                        "__pthread_cond_wait" });
}

bool IsWaiting(const char* symbol) {
  return IsDoubleUnderscoredAndInList(symbol,
                                      { "__GI___pthread_mutex_lock" });
}

}  // anonymous namespace

bool GlogSymbolize(void *pc, char *out, int out_size) {
  return google::Symbolize(pc, out, out_size);
}

// If group is specified it is filled with value corresponding to this stack trace.
void SymbolizeAddress(
    const StackTraceLineFormat stack_trace_line_format,
    void* pc,
    std::string* buf,
    StackTraceGroup* group,
    libbacktrace::GlobalBacktraceState* global_backtrace_state) {
  // The return address 'pc' on the stack is the address of the instruction
  // following the 'call' instruction. In the case of calling a function annotated
  // 'noreturn', this address may actually be the first instruction of the next
  // function, because the function we care about ends with the 'call'.
  // So, we subtract 1 from 'pc' so that we're pointing at the 'call' instead
  // of the return address.
  //
  // For example, compiling a C program with -O2 that simply calls 'abort()' yields
  // the following disassembly:
  //     Disassembly of section .text:
  //
  //     0000000000400440 <main>:
  //       400440:   48 83 ec 08             sub    $0x8,%rsp
  //       400444:   e8 c7 ff ff ff          callq  400410 <abort@plt>
  //
  //     0000000000400449 <_start>:
  //       400449:   31 ed                   xor    %ebp,%ebp
  //       ...
  //
  // If we were to take a stack trace while inside 'abort', the return pointer
  // on the stack would be 0x400449 (the first instruction of '_start'). By subtracting
  // 1, we end up with 0x400448, which is still within 'main'.
  //
  // This also ensures that we point at the correct line number when using addr2line
  // on logged stacks.
  pc = reinterpret_cast<void*>(reinterpret_cast<size_t>(pc) - 1);
#ifdef __linux__
  if (FLAGS_use_libbacktrace) {
    if (!global_backtrace_state) {
      global_backtrace_state = libbacktrace::GetGlobalBacktraceState();
    }
    struct backtrace_state* const backtrace_state = global_backtrace_state->GetState();

    // Avoid multi-threaded access to libbacktrace which causes high memory consumption.
    std::lock_guard l(*global_backtrace_state->mutex());

    libbacktrace::BacktraceContext context;
    context.stack_trace_line_format = stack_trace_line_format;
    context.buf = buf;
    backtrace_pcinfo(backtrace_state, reinterpret_cast<uintptr_t>(pc),
                     libbacktrace::BacktraceFullCallback, libbacktrace::BacktraceErrorCallback,
                     &context);
    return;
  }
#endif
  char tmp[1024];
  const char* symbol = kUnknownSymbol;

  if (GlogSymbolize(pc, tmp, sizeof(tmp))) {
    symbol = tmp;
    if (group) {
      if (IsWaiting(symbol)) {
        *group = StackTraceGroup::kWaiting;
      } else if (IsIdle(symbol)) {
        *group = StackTraceGroup::kIdle;
      }
    }
  }

  StringAppendF(buf, kStackTraceEntryFormat, kPrintfPointerFieldWidth, pc, symbol);
  // We are appending the end-of-line character separately because we want to reuse the same
  // format string for libbacktrace callback and glog-based symbolization, and we have an extra
  // file name / line number component before the end-of-line in the libbacktrace case.
  buf->push_back('\n');
}

std::string DemangleName(const char* mangled_name) {
  int demangle_status = 0;
  char* demangled_name =
      abi::__cxa_demangle(mangled_name, nullptr /* output_buffer */, nullptr /* length */,
                          &demangle_status);
  std::string ret_val = demangle_status == kDemangleOk ? demangled_name : mangled_name;
  free(demangled_name);
  return ret_val;
}

}  // namespace yb